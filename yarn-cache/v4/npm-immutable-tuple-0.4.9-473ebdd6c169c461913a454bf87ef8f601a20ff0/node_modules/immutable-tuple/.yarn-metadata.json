{
  "manifest": {
    "name": "immutable-tuple",
    "version": "0.4.9",
    "description": "Immutable finite list objects with constant-time equality testing (===) and no memory leaks",
    "license": "MIT",
    "author": {
      "name": "Ben Newman",
      "email": "ben@benjamn.com",
      "url": "https://github.com/benjamn"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/benjamn/immutable-tuple.git"
    },
    "homepage": "https://github.com/benjamn/immutable-tuple#readme",
    "bugs": {
      "url": "https://github.com/benjamn/immutable-tuple/issues"
    },
    "main": "dist/tuple.js",
    "module": "dist/tuple.mjs",
    "scripts": {
      "test": "mocha --require reify --full-trace --reporter spec test/tests.js",
      "docs": "docco src/*.js",
      "prepublish": "./scripts/build.sh"
    },
    "keywords": [
      "immutable",
      "tuple",
      "sequence",
      "persistent",
      "data",
      "data structure",
      "functional",
      "intern",
      "interned",
      "internalized",
      "memoization",
      "equality",
      "deep equality",
      "weakmap"
    ],
    "devDependencies": {
      "docco": "^0.8.0",
      "mocha": "^5.0.0",
      "reify": "^0.13.7",
      "rollup": "^0.55.1",
      "rollup-plugin-buble": "^0.18.0",
      "rollup-plugin-uglify": "^3.0.0"
    },
    "reify": {
      "cache-directory": "test/.cache"
    },
    "_registry": "npm",
    "_loc": "yarn-cache/v4/npm-immutable-tuple-0.4.9-473ebdd6c169c461913a454bf87ef8f601a20ff0/node_modules/immutable-tuple/package.json",
    "readmeFilename": "README.md",
    "readme": "# immutable-tuple [![Build Status](https://travis-ci.org/benjamn/immutable-tuple.svg?branch=master)](https://travis-ci.org/benjamn/immutable-tuple)\n\nImmutable finite list objects with constant-time equality testing (`===`) and no memory leaks.\n\n## Installation\n\nFirst install the package from npm:\n\n```sh\nnpm install immutable-tuple\n```\n\nor clone it from GitHub and then run `npm install` to compile the source code:\n\n```sh\ngit clone https://github.com/benjamn/immutable-tuple.git\ncd immutable-tuple\nnpm install\nnpm test # if skeptical\n```\n\n## Usage\n\nThis package exports a single function called `tuple`, both as a `default` export and as an equivalent named export, so all of the following import styles will work:\n\n```js\nimport tuple from \"immutable-tuple\";\nimport { tuple } from \"immutable-tuple\";\nconst { tuple } = require(\"immutable-tuple\");\nconst tuple = require(\"immutable-tuple\").tuple;\n```\n\n### Constructing `tuple`s\n\nThe `tuple` function takes any number of arguments and returns a unique, immutable object that inherits from `tuple.prototype` and is guaranteed to be `===` any other `tuple` object created from the same sequence of arguments:\n\n```js\nimport assert from \"assert\";\n\nconst obj = { asdf: 1234 };\nconst t1 = tuple(1, \"asdf\", obj);\nconst t2 = tuple(1, \"asdf\", obj);\n\nassert.strictEqual(t1 === t2, true);\nassert.strictEqual(t1, t2);\n```\n\nAlthough the `tuple` function can be invoked using `new tuple(...)` syntax, using `new` is not recommended, since the new object will simply be thrown away.\n\n### Own `tuple` properties\n\nThe `tuple` object has a fixed numeric `length` property, and its elements may be accessed using array index notation:\n\n```js\nassert.strictEqual(t1.length, 3);\n\nt1.forEach((x, i) => {\n  assert.strictEqual(x, t2[i]);\n});\n```\n\n### Nested `tuple`s\n\nSince `tuple` objects are just another kind of JavaScript object, naturally `tuple`s can contain other `tuple`s:\n\n```js\nassert.strictEqual(\n  tuple(t1, t2),\n  tuple(t2, t1)\n);\n\nassert.strictEqual(\n  tuple(1, t2, 3)[1][2],\n  obj\n);\n```\n\nHowever, because tuples are immutable and always distinct from any of their arguments, it is not possible for a `tuple` to contain itself, nor to contain another `tuple` that contains the original `tuple`, and so forth.\n\n### Constant time `===` equality\n\nSince `tuple` objects are identical when (and only when) their elements are identical, any two tuples can be compared for equality in constant time, regardless of how many elements they contain.\n\nThis behavior also makes `tuple` objects useful as keys in a `Map`, or elements in a `Set`, without any extra hashing or equality logic:\n\n```js\nconst map = new Map;\n\nmap.set(tuple(1, 12, 3), {\n  author: tuple(\"Ben\", \"Newman\"),\n  releaseDate: Date.now()\n});\n\nconst version = \"1.12.3\";\nconst info = map.get(tuple(...version.split(\".\").map(Number)));\nif (info) {\n  console.log(info.author[1]); // \"Newman\"\n}\n```\n\n### `Array` methods\n\nEvery non-destructive method of `Array.prototype` is supported by `tuple.prototype`, including `sort` and `reverse`, which return a modified copy of the `tuple` without altering the original:\n\n```js\nassert.strictEqual(\n  tuple(\"a\", \"b\", \"c\").slice(1, -1),\n  tuple(\"b\")\n);\n\nassert.strictEqual(\n  tuple(6, 2, 8, 1, 3, 0).sort(),\n  tuple(0, 1, 2, 3, 6, 8)\n);\n\nassert.strictEqual(\n  tuple(1).concat(2, tuple(3, 4), 5),\n  tuple(1, 2, 3, 4, 5)\n);\n```\n\n### Shallow immutability\n\nWhile the identity, number, and order of elements in a `tuple` is fixed, please note that the contents of the individual elements are not frozen in any way:\n\n```js\nconst obj = { asdf: 1234 };\ntuple(1, \"asdf\", obj)[2].asdf = \"oyez\";\nassert.strictEqual(obj.asdf, \"oyez\");\n```\n\n### Iterability\n\nEvery `tuple` object is array-like and iterable, so `...` spreading and destructuring work as they should:\n\n```js\nfunc(...tuple(a, b));\nfunc.apply(this, tuple(c, d, e));\n\nassert.deepEqual(\n  [1, ...tuple(2, 3), 4],\n  [1, 2, 3, 4]\n);\n\nassert.strictEqual(\n  tuple(1, ...tuple(2, 3), 4),\n  tuple(1, 2, 3, 4)\n);\n\nconst [a, [_, b]] = tuple(1, tuple(2, 3), 4);\nassert.strictEqual(a, 1);\nassert.strictEqual(b, 3);\n```\n\n### `tuple.isTuple(value)`\n\nSince the `immutable-tuple` package could be installed multiple times in an application, there is no guarantee that the `tuple` constructor or `tuple.prototype` will be unique, so `value instanceof tuple` is unreliable. Instead, to test if a value is a `tuple`, you should use `tuple.isTuple(value)`.\n\nFortunately, even if your application uses multiple different `tuple` constructors from different copies of this library, the resulting `tuple` instances will still be `===` each other when their elements are the same. This is especially convenient given that this library provides both a CommonJS bundle and an ECMAScript module bundle, and some module systems might accidentally load those bundles simultaneously.\n\n\n## Implementation details\n\nThanks to [Docco](http://ashkenas.com/docco/), you can read my implementation comments side-by-side with the actual code by visiting [the GitHub pages site](https://benjamn.github.io/immutable-tuple/) for this repository.\n\n### Instance pooling (internalization)\n\nAny data structure that guarantees `===` equality based on structural equality must maintain some sort of internal pool of previously encountered instances.\n\nImplementing such a pool for `tuple`s is fairly straightforward (though feel free to give it some thought before reading this code, if you like figuring things out for yourself):\n\n```js\nconst pool = new Map;\n\nfunction tuple(...items) {\n  let node = pool; \n\n  items.forEach(item => {\n    let child = node.get(item);\n    if (!child) node.set(item, child = new Map);\n    node = child;\n  });\n\n  // If we've created a tuple instance for this sequence of elements before,\n  // return that instance again. Otherwise create a new immutable tuple instance\n  // with the same (frozen) elements as the items array.\n  return node.tuple || (node.tuple = Object.create(\n    tuple.prototype,\n    Object.getOwnPropertyDescriptors(Object.freeze(items))\n  ));\n}\n```\n\nThis implementation is pretty good, because it requires only linear time (_O_(`items.length`)) to determine if a `tuple` has been created previously for the given `items`, and you can't do better than linear time (asymptotically speaking) because you have to look at all the items.\n\nThis code is also useful as an illustration of exactly how the `tuple` constructor behaves, in case you weren't satisfied by my examples in the previous section.\n\n### Garbage collection\n\nThe simple implementation above has a serious problem: in a garbage-collected language like JavaScript, the `pool` itself will retain references to all `tuple` objects ever created, which prevents `tuple` objects and their elements (which may be very large objects) from ever being reclaimed by the garbage collector, even after they become unreachable by any other means. In other words, storing objects in this kind of `tuple` would inevitably cause **memory leaks**.\n\nTo solve this problem, it's tempting to try changing `Map` to [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) here:\n\n```js\nconst pool = new WeakMap;\n```\n\nand here:\n\n```js\nif (!child) node.set(item, child = new WeakMap);\n```\n\nThis approach is appealing because a `WeakMap` should allow its keys to be reclaimed by the garbage collector. That's the whole point of a `WeakMap`, after all. Once a `tuple` becomes unreachable because the program has stopped using it anywhere else, its elements are free to disappear from the pool of `WeakMap`s whenever they too become unreachable. In other words, something like a `WeakMap` is exactly what we need here.\n\nUnfortunately, this strategy stumbles because a `tuple` can contain primitive values as well as object references, whereas a `WeakMap` only allows keys that are object references. In other words, `node.set(item, ...)` would fail whenever `item` is not an object, if `node` is a `WeakMap`. To see how the `immutable-tuple` library gets around this `WeakMap` limitation, have a look at [this module](https://benjamn.github.io/immutable-tuple/src/universal-weak-map.html).\n\nAstute readers may object that some bookkeeping data remains in memory when you create `tuple` objects with prefixes of primitive values, but the important thing is that no user-defined objects are kept alive by the `pool`. That said, if you have any ideas for reclaiming chains of `._strongMap` data, please [open an issue](https://github.com/benjamn/immutable-tuple/issues/new) or [submit a pull request](https://github.com/benjamn/immutable-tuple/pulls)!\n",
    "licenseText": "MIT License\n\nCopyright (c) 2018 Ben Newman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/immutable-tuple/-/immutable-tuple-0.4.9.tgz#473ebdd6c169c461913a454bf87ef8f601a20ff0",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/immutable-tuple/-/immutable-tuple-0.4.9.tgz",
    "hash": "473ebdd6c169c461913a454bf87ef8f601a20ff0",
    "integrity": "sha512-LWbJPZnidF8eczu7XmcnLBsumuyRBkpwIRPCZxlojouhBo5jEBO4toj6n7hMy6IxHU/c+MqDSWkvaTpPlMQcyA==",
    "registry": "npm",
    "packageName": "immutable-tuple"
  },
  "registry": "npm",
  "hash": "473ebdd6c169c461913a454bf87ef8f601a20ff0"
}