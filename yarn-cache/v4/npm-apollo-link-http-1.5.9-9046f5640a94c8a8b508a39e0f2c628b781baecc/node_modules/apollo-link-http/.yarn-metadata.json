{
  "manifest": {
    "name": "apollo-link-http",
    "version": "1.5.9",
    "description": "HTTP transport layer for GraphQL",
    "author": {
      "name": "Evans Hauser",
      "email": "evanshauser@gmail.com"
    },
    "contributors": [
      {
        "name": "James Baxley",
        "email": "james@meteor.com"
      },
      {
        "name": "Jonas Helfer",
        "email": "jonas@helfer.email"
      },
      {
        "name": "jon wong",
        "email": "j@jnwng.com"
      },
      {
        "name": "Sashko Stubailo",
        "email": "sashko@stubailo.com"
      },
      {
        "name": "Stephen Kao",
        "email": "stephen.yuchen.kao@gmail.com"
      }
    ],
    "license": "MIT",
    "main": "./lib/bundle.umd.js",
    "module": "./lib/index.js",
    "jsnext:main": "./lib/index.js",
    "typings": "./lib/index.d.ts",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/apollographql/apollo-link.git"
    },
    "bugs": {
      "url": "https://github.com/apollographql/apollo-link/issues"
    },
    "homepage": "https://github.com/apollographql/apollo-link#readme",
    "scripts": {
      "build:browser": "browserify ./lib/bundle.umd.js -o=./lib/bundle.js --i apollo-link && npm run minify:browser",
      "build": "tsc -p .",
      "bundle": "rollup -c",
      "clean": "rimraf lib/* && rimraf coverage/*",
      "coverage": "jest --coverage",
      "filesize": "npm run build && npm run build:browser",
      "lint": "tslint --type-check -p tsconfig.json -c ../../tslint.json src/*.ts",
      "minify:browser": "uglifyjs -c -m -o ./lib/bundle.min.js -- ./lib/bundle.js",
      "postbuild": "npm run bundle",
      "prebuild": "npm run clean",
      "prepublishOnly": "npm run clean && npm run build",
      "test": "jest",
      "watch": "tsc -w -p . & rollup -c -w"
    },
    "dependencies": {
      "apollo-link": "^1.2.6",
      "apollo-link-http-common": "^0.2.8"
    },
    "peerDependencies": {
      "graphql": "^0.11.0 || ^0.12.0 || ^0.13.0 || ^14.0.0"
    },
    "devDependencies": {
      "@types/graphql": "14.0.3",
      "@types/jest": "22.2.3",
      "apollo-fetch": "0.7.0",
      "browserify": "16.2.3",
      "fetch-mock": "6.5.2",
      "graphql": "14.0.2",
      "graphql-tag": "2.10.0",
      "jest": "22.4.4",
      "object-to-querystring": "1.0.8",
      "rimraf": "2.6.1",
      "rollup": "0.67.4",
      "ts-jest": "22.4.6",
      "tslint": "5.11.0",
      "typescript": "3.0.3",
      "uglify-js": "3.4.9"
    },
    "jest": {
      "transform": {
        ".(ts|tsx)": "ts-jest"
      },
      "testRegex": "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
      "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
      ],
      "mapCoverage": true,
      "testPathIgnorePatterns": [
        "/node_modules/",
        "sharedHttpTests.ts"
      ],
      "testURL": "http://localhost"
    },
    "_registry": "npm",
    "_loc": "yarn-cache/v4/npm-apollo-link-http-1.5.9-9046f5640a94c8a8b508a39e0f2c628b781baecc/node_modules/apollo-link-http/package.json",
    "readmeFilename": "README.md",
    "readme": "---\ntitle: apollo-link-http\ndescription: Get GraphQL results over a network using HTTP fetch.\n---\n\nThe http link is the most common Apollo Link, a system of modular components\nfor GraphQL networking. If you haven't done so already, [read the Apollo Link\ndocs](https://www.apollographql.com/docs/link/#usage) to learn about the Apollo\nLink ecosystem and how to use this link with libraries like Apollo Client and\ngraphql-tools, or as a standalone client.\n\nThe http link is a terminating link that fetches GraphQL results from a GraphQL\nendpoint over an http connection. The http link supports both POST and GET\nrequests with the ability change the http options on a per query basis. This\ncan be used for authentication, persisted queries, dynamic uris, and other\ngranular updates.\n\n<h2 id=\"usage\">Usage</h2>\n\nImport and initialize this link in just two lines:\n\n```js\nimport { createHttpLink } from \"apollo-link-http\";\n\nconst link = createHttpLink({ uri: \"/graphql\" });\n```\n\n<h2 id=\"options\">Options</h2>\n\nHTTP Link takes an object with some options on it to customize the behavior of the link. If your server supports it, the HTTP link can also send over metadata about the request in the extensions field. To enable this, pass `includeExtensions` as true. The options you can pass are outlined below:\n\n* `uri`: the URI key is a string endpoint or function resolving to an endpoint -- will default to \"/graphql\" if not specified\n* `includeExtensions`: allow passing the extensions field to your graphql server, defaults to false\n* `fetch`: a `fetch` compatible API for making a request\n* `headers`: an object representing values to be sent as headers on the request\n* `credentials`: a string representing the credentials policy you want for the fetch call. Possible values are: `omit`, `include` and `same-origin`\n* `fetchOptions`: any overrides of the fetch options argument to pass to the fetch call\n* `useGETForQueries`: set to `true` to use the HTTP `GET` method for queries (but not for mutations)\n\n<h2 id=\"fetch\">Fetch polyfill</h2>\n\nThe HTTP Link relies on having `fetch` present in your runtime environment. If you are running on react-native, or modern browsers, this should be no problem. If you are targeting an environment without `fetch` such as older browsers or the server, you will need to pass your own `fetch` to the link through the options. We recommend [`unfetch`](https://github.com/developit/unfetch) for older browsers and [`node-fetch`](https://github.com/bitinn/node-fetch) for running in Node.\n\n<h2 id=\"context\">Context</h2>\n\nThe Http Link uses the `headers` field on the context to allow passing headers to the HTTP request. It also supports the `credentials` field for defining credentials policy, `uri` for changing the endpoint dynamically, and `fetchOptions` to allow generic fetch overrides (i.e. `method: \"GET\"`). These options will override the same key if passed when creating the the link.\n\nNote that if you set `fetchOptions.method` to `GET`, the http link will follow the [standard GraphQL HTTP GET encoding](http://graphql.org/learn/serving-over-http/#get-request): the query, variables, operation name, and extensions will be passed as query parameters rather than in the HTTP request body. If you want mutations to continue to be sent as non-idempotent `POST` requests, set the top-level `useGETForQueries` option to `true` instead of setting `fetchOptions.method` to `GET`.\n\nThis link also attaches the response from the `fetch` operation on the context as `response` so you can access it from within another link.\n\n* `headers`: an object representing values to be sent as headers on the request\n* `credentials`: a string representing the credentials policy you want for the fetch call. Possible values are: `omit`, `include` and `same-origin`\n* `uri`: a string of the endpoint you want to fetch from\n* `fetchOptions`: any overrides of the fetch options argument to pass to the fetch call\n* `response`: this is the raw response from the fetch request after it is made.\n* `http`: this is an object to control fine grained aspects of the http link itself, such as persisted queries (see below)\n\n<h3 id=\"persisted-queries\">Persisted queries</h3>\n\nThe http link supports an advanced GraphQL feature called persisted queries. This allows you to not send the stringified query over the wire, but instead send some kind of identifier of the query. To support this you need to attach the id somewhere to the extensions field and pass the following options to the context:\n\n```js\noperation.setContext({\n  http: {\n    includeExtensions: true,\n    includeQuery: false,\n  }\n})\n```\n\nThe `http` object on context currently supports two keys:\n\n* `includeExtensions`: Send the extensions object for this request.\n* `includeQuery`: Don't send the `query` field for this request.\n\nOne way to use persisted queries is with [apollo-link-persisted-queries](https://github.com/apollographql/apollo-link-persisted-queries) and [Apollo Engine](https://www.apollographql.com/docs/engine/auto-persisted-queries.html).\n\n<h3 id=\"passing-context\">Passing context per query</h3>\n\nApollo Client supports passing context separately for every query, so you can do things like pass a special header for a single query invocation if you need to.\n\n```js\nimport HttpLink from \"apollo-link-http\";\nimport ApolloClient from \"apollo-client\";\nimport { InMemoryCache } from \"apollo-cache-inmemory\";\n\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: \"/graphql\" }),\n  cache: new InMemoryCache()\n});\n\n// a query with apollo-client\nclient.query({\n  query: MY_QUERY,\n  context: {\n    // example of setting the headers with context per operation\n    headers: {\n      special: \"Special header value\"\n    }\n  }\n});\n```\n\n<h2 id=\"error\">Errors</h2>\n\nThe Http Link draws a distinction between client, server and GraphQL errors. Server errors can occur in three different scenarios: parse, network and data errors. [`apollo-link-error`](error.html) provides an [interface](error.html#Usage) for handling these errors. This list describes the scenarios that cause different errors:\n\n* _Client parse error_: the request body is not-serializable due to circular references for example\n* _Server parse error_: the response from the server cannot be parsed ([response.json()](https://developer.mozilla.org/en-US/docs/Web/API/Body/json))\n* _Server network error_: the response has a status of >= 300\n* _Server data error_: the parse request does not contain `data` or `errors`\n* _GraphQL error_: an objects in the `errors` array for a 200 level status\n\nSince many server implementations can return a valid GraphQL result on a server network error, the thrown `Error` object contains the parsed server result. A server data error also receives the parsed result.\n\nThe table below provides a summary of error, `Observable` method called by the HTTP link, and type of error thrown for each failure:\n\n| Error          | Callback | Error Type         |\n| -------------- | :------: | ------------------ |\n| Client Parse   | `error`  | `ClientParseError` |\n| Server Parse   | `error`  | `ServerParseError` |\n| Server Network | `error`  | `ServerError`      |\n| Server Data    | `error`  | `ServerError`      |\n| GraphQL Error  |  `next`  | `Object`           |\n\nAll error types inherit the `name`, `message`, and nullable `stack` properties from the generic javascript [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error).\n\n```js\n//type ClientParseError\n{\n  parseError: Error;                // Error returned from response.json()\n};\n\n//type ServerParseError\n{\n  response: Response;               // Object returned from fetch()\n  statusCode: number;               // HTTP status code\n  bodyText: string                  // text that was returned from server\n};\n\n//type ServerError\n{\n  result: Record<string, any>;      // Parsed object from server response\n  response: Response;               // Object returned from fetch()\n  statusCode: number;               // HTTP status code\n};\n```\n\n<h2 id=\"custom\">Custom fetching</h2>\n\nYou can use the `fetch` option when creating an http-link to do a lot of custom networking. This is useful if you want to modify the request based on the calculated headers  or calculate the uri based on the operation:\n\n<h3 id=\"custom-auth\">Custom auth</h3>\n\n```js\nconst customFetch = (uri, options) => {\n  const { header } = Hawk.client.header(\n    \"http://example.com:8000/resource/1?b=1&a=2\",\n    \"POST\",\n    { credentials: credentials, ext: \"some-app-data\" }\n  );\n  options.headers.Authorization = header;\n  return fetch(uri, options);\n};\n\nconst link = createHttpLink({ fetch: customFetch });\n```\n\n<h3 id=\"dynamic-uri\">Dynamic URI</h3>\n\n```js\nconst customFetch = (uri, options) => {\n  const { operationName } = JSON.parse(options.body);\n  return fetch(`${uri}/graph/graphql?opname=${operationName}`, options);\n};\n\nconst link = createHttpLink({ fetch: customFetch });\n```\n\n<h2 id=\"upgrading\">Upgrade: Apollo Client 1.0</h2>\n\nIf you previously used either `apollo-fetch` or `apollo-client`'s `createNetworkInterface`, you will need to change the way `use` and `useAfter` are implemented in your app. Both can be implemented by writing a custom link. It's important to note that regardless of whether you're adding middleware or afterware, your Http link will always be last in the chain since it's a terminating link.\n\n#### Middleware\n\n_Before_\n\n```js\n// before\nimport ApolloClient, { createNetworkInterface } from \"apollo-client\";\n\nconst networkInterface = createNetworkInterface({ uri: \"/graphql\" });\n\nnetworkInterface.use([\n  {\n    applyMiddleware(req, next) {\n      if (!req.options.headers) {\n        req.options.headers = {}; // Create the header object if needed.\n      }\n      req.options.headers[\"authorization\"] = localStorage.getItem(\"token\")\n        ? localStorage.getItem(\"token\")\n        : null;\n      next();\n    }\n  }\n]);\n```\n\n_After_\n\n```js\nimport { ApolloLink } from \"apollo-link\";\nimport { createHttpLink } from \"apollo-link-http\";\n\nconst httpLink = createHttpLink({ uri: \"/graphql\" });\nconst middlewareLink = new ApolloLink((operation, forward) => {\n  operation.setContext({\n    headers: {\n      authorization: localStorage.getItem(\"token\") || null\n    }\n  });\n  return forward(operation);\n});\n\n// use with apollo-client\nconst link = middlewareLink.concat(httpLink);\n```\n\n#### Afterware (error)\n\n_Before_\n\n```js\nimport ApolloClient, { createNetworkInterface } from \"apollo-client\";\nimport { logout } from \"./logout\";\n\nconst networkInterface = createNetworkInterface({ uri: \"/graphql\" });\n\nnetworkInterface.useAfter([\n  {\n    applyAfterware({ response }, next) {\n      if (response.statusCode === 401) {\n        logout();\n      }\n      next();\n    }\n  }\n]);\n```\n\n_After_\n\n```js\nimport { ApolloLink } from \"apollo-link\";\nimport { createHttpLink } from \"apollo-link-http\";\nimport { onError } from \"apollo-link-error\";\n\nimport { logout } from \"./logout\";\n\nconst httpLink = createHttpLink({ uri: \"/graphql\" });\nconst errorLink = onError(({ networkError }) => {\n  if (networkError.statusCode === 401) {\n    logout();\n  }\n});\n\n// use with apollo-client\nconst link = errorLink.concat(httpLink);\n```\n\n#### Afterware (data manipulation)\n\n_Before_\n\n```js\nimport ApolloClient, { createNetworkInterface } from \"apollo-client\";\n\nconst networkInterface = createNetworkInterface({ uri: \"/graphql\" });\n\nnetworkInterface.useAfter([\n  {\n    applyAfterware({ response }, next) {\n      if (response.data.user.lastLoginDate) {\n        response.data.user.lastLoginDate = new Date(\n          response.data.user.lastLoginDate\n        );\n      }\n      next();\n    }\n  }\n]);\n```\n\n_After_\n\n```js\nimport { ApolloLink } from \"apollo-link\";\nimport { createHttpLink } from \"apollo-link-http\";\n\nconst httpLink = createHttpLink({ uri: \"/graphql\" });\nconst addDatesLink = new ApolloLink((operation, forward) => {\n  return forward(operation).map(response => {\n    if (response.data.user.lastLoginDate) {\n      response.data.user.lastLoginDate = new Date(\n        response.data.user.lastLoginDate\n      );\n    }\n    return response;\n  });\n});\n\n// use with apollo-client\nconst link = addDatesLink.concat(httpLink);\n```\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/apollo-link-http/-/apollo-link-http-1.5.9.tgz#9046f5640a94c8a8b508a39e0f2c628b781baecc",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/apollo-link-http/-/apollo-link-http-1.5.9.tgz",
    "hash": "9046f5640a94c8a8b508a39e0f2c628b781baecc",
    "integrity": "sha512-9tJy2zGm4Cm/1ycScDNZJe51dgnTSfKx7pKIgPZmcxkdDpgUY2DZitDH6ZBv4yp9z8MC9Xr9wgwc29s6hcadUQ==",
    "registry": "npm",
    "packageName": "apollo-link-http"
  },
  "registry": "npm",
  "hash": "9046f5640a94c8a8b508a39e0f2c628b781baecc"
}