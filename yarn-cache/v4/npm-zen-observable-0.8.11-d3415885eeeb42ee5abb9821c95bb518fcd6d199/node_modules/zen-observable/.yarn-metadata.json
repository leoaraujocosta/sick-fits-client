{
  "manifest": {
    "name": "zen-observable",
    "version": "0.8.11",
    "repository": {
      "type": "git",
      "url": "https://github.com/zenparsing/zen-observable.git"
    },
    "description": "An Implementation of ES Observables",
    "homepage": "https://github.com/zenparsing/zen-observable",
    "license": "MIT",
    "devDependencies": {
      "babel-cli": "^6.26.0",
      "babel-preset-es2015": "^6.24.1",
      "eslint": "^4.16.0",
      "mocha": "^5.0.0"
    },
    "dependencies": {},
    "scripts": {
      "test": "mocha --recursive --require ./scripts/mocha-require",
      "lint": "eslint src/*",
      "build": "git clean -dfX ./lib && node ./scripts/build",
      "prepublishOnly": "eslint src/* && npm test && npm run build"
    },
    "_registry": "npm",
    "_loc": "yarn-cache/v4/npm-zen-observable-0.8.11-d3415885eeeb42ee5abb9821c95bb518fcd6d199/node_modules/zen-observable/package.json",
    "readmeFilename": "README.md",
    "readme": "# zen-observable\n\nAn implementation of Observables for JavaScript. Requires Promises or a Promise polyfill.\n\n## Install\n\n```sh\nnpm install zen-observable\n```\n\n## Usage\n\n```js\nimport Observable from 'zen-observable';\n\nObservable.of(1, 2, 3).subscribe(x => console.log(x));\n```\n\n## API\n\n### new Observable(subscribe)\n\n```js\nlet observable = new Observable(observer => {\n  // Emit a single value after 1 second\n  let timer = setTimeout(() => {\n    observer.next('hello');\n    observer.complete();\n  }, 1000);\n\n  // On unsubscription, cancel the timer\n  return () => clearTimeout(timer);\n});\n```\n\nCreates a new Observable object using the specified subscriber function.  The subscriber function is called whenever the `subscribe` method of the observable object is invoked.  The subscriber function is passed an *observer* object which has the following methods:\n\n- `next(value)` Sends the next value in the sequence.\n- `error(exception)` Terminates the sequence with an exception.\n- `complete()` Terminates the sequence successfully.\n- `closed` A boolean property whose value is `true` if the observer's subscription is closed.\n\nThe subscriber function can optionally return either a cleanup function or a subscription object.  If it returns a cleanup function, that function will be called when the subscription has closed.  If it returns a subscription object, then the subscription's `unsubscribe` method will be invoked when the subscription has closed.\n\n### Observable.of(...items)\n\n```js\n// Logs 1, 2, 3\nObservable.of(1, 2, 3).subscribe(x => {\n  console.log(x);\n});\n```\n\nReturns an observable which will emit each supplied argument.\n\n### Observable.from(value)\n\n```js\nlet list = [1, 2, 3];\n\n// Iterate over an object\nObservable.from(list).subscribe(x => {\n  console.log(x);\n});\n```\n\n```js\n// Convert something 'observable' to an Observable instance\nObservable.from(otherObservable).subscribe(x => {\n  console.log(x);\n});\n```\n\nConverts `value` to an Observable.\n\n- If `value` is an implementation of Observable, then it is converted to an instance of Observable as defined by this library.\n- Otherwise, it is converted to an Observable which synchronously iterates over `value`.\n\n### observable.subscribe([observer])\n\n```js\nlet subscription = observable.subscribe({\n  next(x) { console.log(x) },\n  error(err) { console.log(`Finished with error: ${ err }`) },\n  complete() { console.log('Finished') }\n});\n```\n\nSubscribes to the observable.  Observer objects may have any of the following methods:\n\n- `next(value)` Receives the next value of the sequence.\n- `error(exception)` Receives the terminating error of the sequence.\n- `complete()` Called when the stream has completed successfully.\n\nReturns a subscription object that can be used to cancel the stream.\n\n### observable.subscribe(nextCallback[, errorCallback, completeCallback])\n\n```js\nlet subscription = observable.subscribe(\n  x => console.log(x),\n  err => console.log(`Finished with error: ${ err }`),\n  () => console.log('Finished')\n);\n```\n\nSubscribes to the observable with callback functions. Returns a subscription object that can be used to cancel the stream.\n\n### observable.forEach(callback)\n\n```js\nobservable.forEach(x => {\n  console.log(`Received value: ${ x }`);\n}).then(() => {\n  console.log('Finished successfully')\n}).catch(err => {\n  console.log(`Finished with error: ${ err }`);\n})\n```\n\nSubscribes to the observable and returns a Promise for the completion value of the stream.  The `callback` argument is called once for each value in the stream.\n\n### observable.filter(callback)\n\n```js\nObservable.of(1, 2, 3).filter(value => {\n  return value > 2;\n}).subscribe(value => {\n  console.log(value);\n});\n// 3\n```\n\nReturns a new Observable that emits all values which pass the test implemented by the `callback` argument.\n\n### observable.map(callback)\n\nReturns a new Observable that emits the results of calling the `callback` argument for every value in the stream.\n\n```js\nObservable.of(1, 2, 3).map(value => {\n  return value * 2;\n}).subscribe(value => {\n  console.log(value);\n});\n// 2\n// 4\n// 6\n```\n\n### observable.reduce(callback [,initialValue])\n\n```js\nObservable.of(0, 1, 2, 3, 4).reduce((previousValue, currentValue) => {\n  return previousValue + currentValue;\n}).subscribe(result => {\n  console.log(result);\n});\n// 10\n```\n\nReturns a new Observable that applies a function against an accumulator and each value of the stream to reduce it to a single value.\n\n### observable.concat(...sources)\n\n```js\nObservable.of(1, 2, 3).concat(\n  Observable.of(4, 5, 6),\n  Observable.of(7, 8, 9)\n).subscribe(result => {\n  console.log(result);\n});\n// 1, 2, 3, 4, 5, 6, 7, 8, 9\n```\n\nMerges the current observable with additional observables.\n",
    "licenseText": "Copyright (c) 2018 zenparsing (Kevin Smith)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/zen-observable/-/zen-observable-0.8.11.tgz#d3415885eeeb42ee5abb9821c95bb518fcd6d199",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/zen-observable/-/zen-observable-0.8.11.tgz",
    "hash": "d3415885eeeb42ee5abb9821c95bb518fcd6d199",
    "integrity": "sha512-N3xXQVr4L61rZvGMpWe8XoCGX8vhU35dPyQ4fm5CY/KDlG0F75un14hjbckPXTDuKUY6V0dqR2giT6xN8Y4GEQ==",
    "registry": "npm",
    "packageName": "zen-observable"
  },
  "registry": "npm",
  "hash": "d3415885eeeb42ee5abb9821c95bb518fcd6d199"
}