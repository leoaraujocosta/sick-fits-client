{
  "manifest": {
    "name": "memoize-one",
    "version": "4.1.0",
    "description": "A memoization library which only remembers the latest invocation",
    "main": "dist/memoize-one.cjs.js",
    "module": "dist/memoize-one.esm.js",
    "sideEffects": false,
    "author": {
      "name": "Alex Reardon",
      "email": "alexreardon@gmail.com"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/alexreardon/memoize-one.git"
    },
    "files": [
      "/dist",
      "/src"
    ],
    "keywords": [
      "memoize",
      "memoization",
      "cache",
      "performance"
    ],
    "dependencies": {},
    "devDependencies": {
      "@babel/core": "^7.2.0",
      "@babel/preset-env": "^7.2.0",
      "@babel/preset-flow": "^7.0.0",
      "babel-core": "^7.0.0-bridge.0",
      "babel-eslint": "10.0.1",
      "babel-jest": "^23.6.0",
      "cross-env": "^5.2.0",
      "eslint": "5.10.0",
      "eslint-plugin-flowtype": "^3.2.0",
      "eslint-plugin-jest": "^22.1.2",
      "flow-bin": "0.88.0",
      "jest": "^23.6.0",
      "rimraf": "2.6.2",
      "rollup": "^0.67.4",
      "rollup-plugin-babel": "^4.0.3",
      "rollup-plugin-commonjs": "^9.2.0",
      "rollup-plugin-replace": "^2.1.0",
      "rollup-plugin-uglify": "^6.0.0"
    },
    "scripts": {
      "validate": "yarn run lint && yarn run typecheck",
      "test": "cross-env NODE_ENV=test jest",
      "typecheck": "flow check",
      "lint": "eslint src test",
      "build": "yarn run build:clean && yarn run build:dist && yarn run build:flow",
      "build:clean": "rimraf dist",
      "build:dist": "rollup -c",
      "build:flow": "echo \"// @flow\n\nexport * from '../src';\" > dist/memoize-one.cjs.js.flow",
      "prepublish": "yarn run build"
    },
    "_registry": "npm",
    "_loc": "yarn-cache/v4/npm-memoize-one-4.1.0-a2387c58c03fff27ca390c31b764a79addf3f906/node_modules/memoize-one/package.json",
    "readmeFilename": "README.md",
    "readme": "# memoize-one\n\nA memoization library that only caches the result of the most recent arguments.\n\n[![Build Status](https://travis-ci.org/alexreardon/memoize-one.svg?branch=master)](https://travis-ci.org/alexreardon/memoize-one)\n[![npm](https://img.shields.io/npm/v/memoize-one.svg)](https://www.npmjs.com/package/memoize-one)\n[![dependencies](https://david-dm.org/alexreardon/memoize-one.svg)](https://david-dm.org/alexreardon/memoize-one)\n[![Downloads per month](https://img.shields.io/npm/dm/memoize-one.svg)](https://www.npmjs.com/package/memoize-one)\n[![min](https://img.shields.io/bundlephobia/min/memoize-one.svg)](https://www.npmjs.com/package/memoize-one)\n[![minzip](https://img.shields.io/bundlephobia/minzip/memoize-one.svg)](https://www.npmjs.com/package/memoize-one)\n\n## Rationale\n\nCache invalidation is hard:\n\n> There are only two hard things in Computer Science: cache invalidation and naming things.\n>\n> *Phil Karlton*\n\nSo keep things simple and just use a cache size of one!\n\nUnlike other memoization libraries, `memoize-one` only remembers the latest arguments and result. No need to worry about cache busting mechanisms such as `maxAge`, `maxSize`, `exclusions` and so on which can be prone to memory leaks. `memoize-one` simply remembers the last arguments, and if the function is next called with the same arguments then it returns the previous result.\n\n## Usage\n\n### Standard usage\n\n```js\nimport memoizeOne from 'memoize-one';\n\nconst add = (a, b) => a + b;\nconst memoizedAdd = memoizeOne(add);\n\nmemoizedAdd(1, 2); // 3\n\nmemoizedAdd(1, 2); // 3\n// Add function is not executed: previous result is returned\n\nmemoizedAdd(2, 3); // 5\n// Add function is called to get new value\n\nmemoizedAdd(2, 3); // 5\n// Add function is not executed: previous result is returned\n\nmemoizedAdd(1, 2); // 3\n// Add function is called to get new value.\n// While this was previously cached,\n// it is not the latest so the cached result is lost\n```\n\n### Custom equality function\n\nYou can also pass in a custom function for checking the equality of two items. The equality function will is used to compare the value of every individual argument.\n\n```js\nimport memoizeOne from 'memoize-one';\nimport deepEqual from 'lodash.isEqual';\n\nconst identity = x => x;\n\nconst defaultMemoization = memoizeOne(identity);\nconst customMemoization = memoizeOne(identity, deepEqual);\n\nconst result1 = defaultMemoization({foo: 'bar'});\nconst result2 = defaultMemoization({foo: 'bar'});\n\nresult1 === result2 // false - difference reference\n\nconst result3 = customMemoization({foo: 'bar'});\nconst result4 = customMemoization({foo: 'bar'});\n\nresult3 === result4 // true - arguments are deep equal\n```\n\n#### Equality function type signature\n\nHere is the expected [flow](http://flowtype.org) type signature for a custom equality function:\n\n```js\ntype EqualityFn = (newValue: mixed, oldValue: mixed, index: number) => boolean;\n```\n\nThe default equality function is a simple shallow equal check\n\n```js\nconst simpleIsEqual: EqualityFn = (a: mixed, b: mixed): boolean => a === b;\n```\n\n#### Equality function with multiple arguments\n\nIf the function you want to memoize takes multiple arguments, your custom equality function will be called once for each argument and will be passed each argument's new value and last value.\n\n```js\nimport memoizeOne from 'memoize-one';\n\nconst makeCountObj = (first, second, third) => ({\n  first: first.count,\n  second: second.count,\n  third: third.count,\n});\n\nconst areCountPropertiesEqual = (newArg, lastArg) => newArg.count === lastArg.count;\n// runs once for first's new and last values, once for second's, etc.\n\nconst memoizedMakeCountObj = memoizeOne(makeCountObj, areCountPropertiesEqual);\n\nconst result1 = memoizedMakeCountObj(\n  {a: '?', count: 1},\n  {a: '$', count: 2},\n  {a: '#', count: 3}\n);\nconst result2 = memoizedMakeCountObj(\n  {b: null, count: 1},\n  {b: null, count: 2},\n  {b: null, count: 3}\n);\n\nresult1 === result2; // true - same reference\n```\n\n#### Equality function index\n\nFor each call of the equality function you are provided with the index of the argument.\n\n```js\nimport memoizeOne from 'memoize-one';\nimport deepEqual from 'lodash.isEqual';\n\nconst myEqualFn = (newArg, lastArg, index) => {\n  // use deep equal for first arg\n  if(index === 0) {\n    return deepEqual(newArg, lastArg);\n  }\n  // use shallow equal for all other arguments\n  return newArg === lastArg;\n}\n\nconst fn = (...args) => {\n  console.log('called with', ...args);\n};\nconst memoized = memoizeOne(fn, myEqualFn);\n\nmemoized({hello: 'world'}, 5);\n// console.log('called with', {hello: 'world'}, 5);\n\nmemoized({hello: 'world'}, 5);\n// no call to console.log\n```\n\n## Installation\n\n```bash\n# yarn\nyarn add memoize-one\n\n# npm\nnpm install memoize-one --save\n```\n\n## Module usage\n\n### ES6 module\n\n```js\nimport memoizeOne from 'memoize-one';\n```\n\n### CommonJS\n\nIf you are in a CommonJS environment (eg [Node](https://nodejs.org)), then **you will need to add `.default` to your import**:\n\n```js\nconst memoizeOne = require('memoize-one').default;\n```\n\n## `this`\n\n### `memoize-one` correctly respects `this` control\n\nThis library takes special care to maintain, and allow control over the the `this` context for **both** the original function being memoized as well as the returned memoized function. Both the original function and the memoized function's `this` context respect [all the `this` controlling techniques](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md):\n\n- new bindings (`new`)\n- explicit binding (`call`, `apply`, `bind`);\n- implicit binding (call site: `obj.foo()`);\n- default binding (`window` or `undefined` in `strict mode`);\n- fat arrow binding (binding to lexical `this`)\n- ignored this (pass `null` as `this` to explicit binding)\n\n### Changes to `this` is considered an argument change\n\nChanges to the running context (`this`) of a function can result in the function returning a different value even though its arguments have stayed the same:\n\n```js\nfunction getA() {\n  return this.a;\n}\n\nconst temp1 = {\n  a: 20,\n};\nconst temp2 = {\n  a: 30,\n}\n\ngetA.call(temp1); // 20\ngetA.call(temp2); // 30\n```\n\nTherefore, in order to prevent against unexpected results, `memoize-one` takes into account the current execution context (`this`) of the memoized function. If `this` is different to the previous invocation then it is considered a change in argument. [further discussion](https://github.com/alexreardon/memoize-one/issues/3).\n\nGenerally this will be of no impact if you are not explicity controlling the `this` context of functions you want to memoize with [explicit binding](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#explicit-binding)  or [implicit binding](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#implicit-binding). `memoize-One` will detect when you are manipulating `this` and will then consider the `this` context as an argument. If `this` changes, it will re-execute the original function even if the arguments have not changed.\n\n## When your result function `throw`s\n\n> There is no caching when your result function throws\n\nIf your result function `throw`s then the memoized function will also throw. The throw will not break the memoized functions existing argument cache. It means the memoized function will pretend like it was never called with arguments that made it `throw`.\n\n```js\nconst canThrow = (name: string) => {\n  console.log('called');\n  if(name === 'throw') {\n    throw new Error(name);\n  }\n  return { name };\n}\n\nconst memoized = memoizeOne(canThrow);\n\nconst value1 = memoized('Alex');\n// console.log => 'called'\nconst value2 = memoized('Alex');\n// result function not called\n\nconsole.log(value1 === value2);\n// console.log => true\n\ntry {\n  memoized('throw');\n  // console.log => 'called'\n} catch(e) {\n  firstError = e;\n}\n\ntry {\n  memoized('throw');\n  // console.log => 'called'\n  // the result function was called again even though it was called twice\n  // with the 'throw' string\n} catch(e) {\n  secondError = e;\n}\n\nconsole.log(firstError !== secondError);\n\n\nconst value3 = memoized('Alex');\n// result function not called as the original memoization cache has not been busted\nconsole.log(value1 === value3);\n// console.log => true\n```\n\n## Performance :rocket:\n\n### Tiny\n\n`memoize-one` is super lightweight at [![min](https://img.shields.io/bundlephobia/min/memoize-one.svg?label=)](https://www.npmjs.com/package/memoize-one) minified and [![minzip](https://img.shields.io/bundlephobia/minzip/memoize-one.svg?label=)](https://www.npmjs.com/package/memoize-one) gzipped. (`1KB` = `1,024 Bytes`)\n\n### Extremely fast\n\n`memoize-one` performs better or on par with than other popular memoization libraries for the purpose of remembering the latest invocation.\n\n**Results**\n\n- [simple arguments](https://www.measurethat.net/Benchmarks/ShowResult/4452)\n- [complex arguments](https://www.measurethat.net/Benchmarks/ShowResult/4488)\n\nThe comparisions are not exhaustive and are primiarly to show that `memoize-one` accomplishes remembering the latest invocation really fast. The benchmarks do not take into account the differences in feature sets, library sizes, parse time, and so on.\n\n## Code health :thumbsup:\n\n- Tested with all built in [JavaScript types](https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch1.md).\n- 100% code coverage\n- [Continuous integration](https://travis-ci.org/alexreardon/memoize-one) to run tests and type checks.\n- [`Flow` types](http://flowtype.org) for safer internal execution and external consumption. Also allows for editor autocompletion.\n- Follows [Semantic versioning (2.0)](http://semver.org/) for safer consumption.\n- No dependencies\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017 Alexander Reardon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/memoize-one/-/memoize-one-4.1.0.tgz#a2387c58c03fff27ca390c31b764a79addf3f906",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/memoize-one/-/memoize-one-4.1.0.tgz",
    "hash": "a2387c58c03fff27ca390c31b764a79addf3f906",
    "integrity": "sha512-2GApq0yI/b22J2j9rhbrAlsHb0Qcz+7yWxeLG8h+95sl1XPUgeLimQSOdur4Vw7cUhrBHwaUZxWFZueojqNRzA==",
    "registry": "npm",
    "packageName": "memoize-one"
  },
  "registry": "npm",
  "hash": "a2387c58c03fff27ca390c31b764a79addf3f906"
}